
On-demand Traffic Light Control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007a4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000818  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00800060  00800060  00000818  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000818  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000848  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  00000884  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001915  00000000  00000000  000009cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000959  00000000  00000000  000022e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cb9  00000000  00000000  00002c3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000214  00000000  00000000  000038f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000850  00000000  00000000  00003b08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000006a1  00000000  00000000  00004358  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d8  00000000  00000000  000049f9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 60 03 	jmp	0x6c0	; 0x6c0 <__vector_1>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	a8 36       	cpi	r26, 0x68	; 104
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <main>
  74:	0c 94 d0 03 	jmp	0x7a0	; 0x7a0 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <APP_init>:
/* Function Definitions */
/* This function initializes the drivers needed for the application. */
void APP_init()
{
	/* Initializing cars LEDS */
	LED_init (PORT_A, CAR_GREEN_LED);
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	81 e4       	ldi	r24, 0x41	; 65
  80:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	LED_init (PORT_A, CAR_YELLOW_LED);
  84:	61 e0       	ldi	r22, 0x01	; 1
  86:	81 e4       	ldi	r24, 0x41	; 65
  88:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	LED_init (PORT_A, CAR_RED_LED);
  8c:	62 e0       	ldi	r22, 0x02	; 2
  8e:	81 e4       	ldi	r24, 0x41	; 65
  90:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	
	/* Initializing pedestrians LEDS */
	LED_init (PORT_B, PEDESTRIANS_GREEN_LED);
  94:	60 e0       	ldi	r22, 0x00	; 0
  96:	82 e4       	ldi	r24, 0x42	; 66
  98:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	LED_init (PORT_B, PEDESTRIANS_YELLOW_LED);
  9c:	61 e0       	ldi	r22, 0x01	; 1
  9e:	82 e4       	ldi	r24, 0x42	; 66
  a0:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	LED_init (PORT_B, PEDESTRIANS_RED_LED);
  a4:	62 e0       	ldi	r22, 0x02	; 2
  a6:	82 e4       	ldi	r24, 0x42	; 66
  a8:	0e 94 cd 01 	call	0x39a	; 0x39a <LED_init>
	
	/* Initializing INT0 */
	INT_init(INTERRUPT_NUMBER0);
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	0e 94 4e 03 	call	0x69c	; 0x69c <INT_init>
	setINT0Callback(APP_switchMode);
  b2:	8d eb       	ldi	r24, 0xBD	; 189
  b4:	91 e0       	ldi	r25, 0x01	; 1
  b6:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <setINT0Callback>
  ba:	08 95       	ret

000000bc <APP_startCarMode>:
	}
}

void APP_startCarMode()
{
	switch(currentCarLed)
  bc:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
  c0:	81 30       	cpi	r24, 0x01	; 1
  c2:	31 f1       	breq	.+76     	; 0x110 <APP_startCarMode+0x54>
  c4:	20 f0       	brcs	.+8      	; 0xce <APP_startCarMode+0x12>
  c6:	82 30       	cpi	r24, 0x02	; 2
  c8:	09 f4       	brne	.+2      	; 0xcc <APP_startCarMode+0x10>
  ca:	81 c0       	rjmp	.+258    	; 0x1ce <APP_startCarMode+0x112>
  cc:	08 95       	ret
	{
		/* Enable car green light.*/
		case CAR_GREEN_LED:
		LED_on (PORT_A, CAR_GREEN_LED);
  ce:	60 e0       	ldi	r22, 0x00	; 0
  d0:	81 e4       	ldi	r24, 0x41	; 65
  d2:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		TIMER0_delay(TIMER0_PRESCALER_1024, DELAY_5_SECONDS);
  d6:	65 e0       	ldi	r22, 0x05	; 5
  d8:	70 e0       	ldi	r23, 0x00	; 0
  da:	80 e0       	ldi	r24, 0x00	; 0
  dc:	94 e0       	ldi	r25, 0x04	; 4
  de:	0e 94 8e 03 	call	0x71c	; 0x71c <TIMER0_delay>
		if(timer0InterruptFlag_g == TRUE)
  e2:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <timer0InterruptFlag_g>
  e6:	81 30       	cpi	r24, 0x01	; 1
  e8:	39 f4       	brne	.+14     	; 0xf8 <APP_startCarMode+0x3c>
		{
			timer0InterruptFlag_g = FALSE;
  ea:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <timer0InterruptFlag_g>
			LED_off(PORT_A, CAR_GREEN_LED);// Closing car green led after coming back from pedestrian mode.
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	81 e4       	ldi	r24, 0x41	; 65
  f2:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
			return;
  f6:	08 95       	ret
		}
		LED_off(PORT_A, CAR_GREEN_LED);
  f8:	60 e0       	ldi	r22, 0x00	; 0
  fa:	81 e4       	ldi	r24, 0x41	; 65
  fc:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		previousCarLed = currentCarLed;
 100:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
 104:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <previousCarLed>
		currentCarLed ++;
 108:	8f 5f       	subi	r24, 0xFF	; 255
 10a:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <currentCarLed>
		break;
 10e:	08 95       	ret
		
		
		/* Blink car yellow light.*/
		case CAR_YELLOW_LED:
		switch(previousCarLed)
 110:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <previousCarLed>
 114:	88 23       	and	r24, r24
 116:	f1 f0       	breq	.+60     	; 0x154 <APP_startCarMode+0x98>
 118:	82 30       	cpi	r24, 0x02	; 2
 11a:	09 f4       	brne	.+2      	; 0x11e <APP_startCarMode+0x62>
 11c:	47 c0       	rjmp	.+142    	; 0x1ac <APP_startCarMode+0xf0>
 11e:	08 95       	ret
		{
			/* Previous LED is green. */
			case CAR_GREEN_LED:
			while (secondsCounter < DELAY_5_SECONDS)
			{
				LED_toggle(PORT_A, CAR_YELLOW_LED);
 120:	61 e0       	ldi	r22, 0x01	; 1
 122:	81 e4       	ldi	r24, 0x41	; 65
 124:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
				TIMER0_delay(TIMER0_PRESCALER_1024, DELAY_1_SECOND);
 128:	61 e0       	ldi	r22, 0x01	; 1
 12a:	70 e0       	ldi	r23, 0x00	; 0
 12c:	80 e0       	ldi	r24, 0x00	; 0
 12e:	94 e0       	ldi	r25, 0x04	; 4
 130:	0e 94 8e 03 	call	0x71c	; 0x71c <TIMER0_delay>
				if(timer0InterruptFlag_g == TRUE)
 134:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <timer0InterruptFlag_g>
 138:	81 30       	cpi	r24, 0x01	; 1
 13a:	39 f4       	brne	.+14     	; 0x14a <APP_startCarMode+0x8e>
				{
					timer0InterruptFlag_g = FALSE;
 13c:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <timer0InterruptFlag_g>
					LED_off(PORT_A, CAR_GREEN_LED);// Closing car green led after coming back from pedestrian mode.
 140:	60 e0       	ldi	r22, 0x00	; 0
 142:	81 e4       	ldi	r24, 0x41	; 65
 144:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
					return;
 148:	08 95       	ret
				}
				secondsCounter++;
 14a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 14e:	8f 5f       	subi	r24, 0xFF	; 255
 150:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		case CAR_YELLOW_LED:
		switch(previousCarLed)
		{
			/* Previous LED is green. */
			case CAR_GREEN_LED:
			while (secondsCounter < DELAY_5_SECONDS)
 154:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 158:	85 30       	cpi	r24, 0x05	; 5
 15a:	10 f3       	brcs	.-60     	; 0x120 <APP_startCarMode+0x64>
					LED_off(PORT_A, CAR_GREEN_LED);// Closing car green led after coming back from pedestrian mode.
					return;
				}
				secondsCounter++;
			}
			LED_off(PORT_A, CAR_YELLOW_LED);
 15c:	61 e0       	ldi	r22, 0x01	; 1
 15e:	81 e4       	ldi	r24, 0x41	; 65
 160:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
			secondsCounter = 0;
 164:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
			previousCarLed = currentCarLed;
 168:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
 16c:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <previousCarLed>
			currentCarLed = CAR_RED_LED;
 170:	82 e0       	ldi	r24, 0x02	; 2
 172:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <currentCarLed>
			break;
 176:	08 95       	ret
			
			/* Previous LED is red. */
			case CAR_RED_LED:
			while (secondsCounter < DELAY_5_SECONDS)
			{
				LED_toggle(PORT_A, CAR_YELLOW_LED);
 178:	61 e0       	ldi	r22, 0x01	; 1
 17a:	81 e4       	ldi	r24, 0x41	; 65
 17c:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
				TIMER0_delay(TIMER0_PRESCALER_1024, DELAY_1_SECOND);
 180:	61 e0       	ldi	r22, 0x01	; 1
 182:	70 e0       	ldi	r23, 0x00	; 0
 184:	80 e0       	ldi	r24, 0x00	; 0
 186:	94 e0       	ldi	r25, 0x04	; 4
 188:	0e 94 8e 03 	call	0x71c	; 0x71c <TIMER0_delay>
				if(timer0InterruptFlag_g == TRUE)
 18c:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <timer0InterruptFlag_g>
 190:	81 30       	cpi	r24, 0x01	; 1
 192:	39 f4       	brne	.+14     	; 0x1a2 <APP_startCarMode+0xe6>
				{
					timer0InterruptFlag_g = FALSE;
 194:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <timer0InterruptFlag_g>
					LED_off(PORT_A, CAR_GREEN_LED);// Closing car green led after coming back from pedestrian mode.
 198:	60 e0       	ldi	r22, 0x00	; 0
 19a:	81 e4       	ldi	r24, 0x41	; 65
 19c:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
					return;
 1a0:	08 95       	ret
				}
				secondsCounter++;
 1a2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1a6:	8f 5f       	subi	r24, 0xFF	; 255
 1a8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			currentCarLed = CAR_RED_LED;
			break;
			
			/* Previous LED is red. */
			case CAR_RED_LED:
			while (secondsCounter < DELAY_5_SECONDS)
 1ac:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 1b0:	85 30       	cpi	r24, 0x05	; 5
 1b2:	10 f3       	brcs	.-60     	; 0x178 <APP_startCarMode+0xbc>
					LED_off(PORT_A, CAR_GREEN_LED);// Closing car green led after coming back from pedestrian mode.
					return;
				}
				secondsCounter++;
			}
			LED_off(PORT_A, CAR_YELLOW_LED);
 1b4:	61 e0       	ldi	r22, 0x01	; 1
 1b6:	81 e4       	ldi	r24, 0x41	; 65
 1b8:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
			secondsCounter = 0;
 1bc:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
			previousCarLed = currentCarLed;
 1c0:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
 1c4:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <previousCarLed>
			currentCarLed = CAR_GREEN_LED;
 1c8:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <currentCarLed>
			break;
 1cc:	08 95       	ret
		break;
		
		
		/* Enable car red light.*/
		case CAR_RED_LED:
		LED_on (PORT_A, CAR_RED_LED);
 1ce:	62 e0       	ldi	r22, 0x02	; 2
 1d0:	81 e4       	ldi	r24, 0x41	; 65
 1d2:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		TIMER0_delay(TIMER0_PRESCALER_1024, DELAY_5_SECONDS);
 1d6:	65 e0       	ldi	r22, 0x05	; 5
 1d8:	70 e0       	ldi	r23, 0x00	; 0
 1da:	80 e0       	ldi	r24, 0x00	; 0
 1dc:	94 e0       	ldi	r25, 0x04	; 4
 1de:	0e 94 8e 03 	call	0x71c	; 0x71c <TIMER0_delay>
		LED_off(PORT_A, CAR_RED_LED);
 1e2:	62 e0       	ldi	r22, 0x02	; 2
 1e4:	81 e4       	ldi	r24, 0x41	; 65
 1e6:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		previousCarLed = currentCarLed;
 1ea:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
 1ee:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <previousCarLed>
		currentCarLed = CAR_YELLOW_LED;
 1f2:	81 e0       	ldi	r24, 0x01	; 1
 1f4:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <currentCarLed>
 1f8:	08 95       	ret

000001fa <APP_start>:
}

/* This function starts the sequence of the application. */
void APP_start()
{
	if(appMode_g == CAR_MODE)
 1fa:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <appMode_g>
 1fe:	81 11       	cpse	r24, r1
 200:	02 c0       	rjmp	.+4      	; 0x206 <APP_start+0xc>
	{
		APP_startCarMode();
 202:	0e 94 5e 00 	call	0xbc	; 0xbc <APP_startCarMode>
 206:	08 95       	ret

00000208 <APP_startPedestrianMode>:
	}
}
void APP_startPedestrianMode()
{
	/* In the first and second cases below, I do not add break; since each case happens after the previous one. */
	switch(currentCarLed)
 208:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <currentCarLed>
 20c:	81 30       	cpi	r24, 0x01	; 1
 20e:	d9 f0       	breq	.+54     	; 0x246 <APP_startPedestrianMode+0x3e>
 210:	20 f0       	brcs	.+8      	; 0x21a <APP_startPedestrianMode+0x12>
 212:	82 30       	cpi	r24, 0x02	; 2
 214:	09 f4       	brne	.+2      	; 0x218 <APP_startPedestrianMode+0x10>
 216:	40 c0       	rjmp	.+128    	; 0x298 <APP_startPedestrianMode+0x90>
 218:	5a c0       	rjmp	.+180    	; 0x2ce <APP_startPedestrianMode+0xc6>
	{
		/* Enable car green light and pedestrian red light.*/
		case CAR_GREEN_LED:
		LED_on(PORT_A, CAR_GREEN_LED);
 21a:	60 e0       	ldi	r22, 0x00	; 0
 21c:	81 e4       	ldi	r24, 0x41	; 65
 21e:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		LED_on(PORT_B, PEDESTRIANS_RED_LED);
 222:	62 e0       	ldi	r22, 0x02	; 2
 224:	82 e4       	ldi	r24, 0x42	; 66
 226:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_5_SECONDS);
 22a:	65 e0       	ldi	r22, 0x05	; 5
 22c:	70 e0       	ldi	r23, 0x00	; 0
 22e:	80 e0       	ldi	r24, 0x00	; 0
 230:	94 e0       	ldi	r25, 0x04	; 4
 232:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
		LED_off(PORT_A, CAR_GREEN_LED);
 236:	60 e0       	ldi	r22, 0x00	; 0
 238:	81 e4       	ldi	r24, 0x41	; 65
 23a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		LED_off(PORT_B, PEDESTRIANS_RED_LED);
 23e:	62 e0       	ldi	r22, 0x02	; 2
 240:	82 e4       	ldi	r24, 0x42	; 66
 242:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		
		
		/* Blink car and pedestrian yellow light.*/
		case CAR_YELLOW_LED:
		secondsCounter = 0;
 246:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
		LED_off(PORT_A, CAR_YELLOW_LED);// stop CAR_YELLOW_LED so that both yellow leds start blinking together.
 24a:	61 e0       	ldi	r22, 0x01	; 1
 24c:	81 e4       	ldi	r24, 0x41	; 65
 24e:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		while (secondsCounter < DELAY_5_SECONDS)
 252:	13 c0       	rjmp	.+38     	; 0x27a <APP_startPedestrianMode+0x72>
		{
			LED_toggle(PORT_A, CAR_YELLOW_LED);
 254:	61 e0       	ldi	r22, 0x01	; 1
 256:	81 e4       	ldi	r24, 0x41	; 65
 258:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
			LED_toggle(PORT_B, PEDESTRIANS_YELLOW_LED);
 25c:	61 e0       	ldi	r22, 0x01	; 1
 25e:	82 e4       	ldi	r24, 0x42	; 66
 260:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
			TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_1_SECOND);
 264:	61 e0       	ldi	r22, 0x01	; 1
 266:	70 e0       	ldi	r23, 0x00	; 0
 268:	80 e0       	ldi	r24, 0x00	; 0
 26a:	94 e0       	ldi	r25, 0x04	; 4
 26c:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
			secondsCounter++;
 270:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 274:	8f 5f       	subi	r24, 0xFF	; 255
 276:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		
		/* Blink car and pedestrian yellow light.*/
		case CAR_YELLOW_LED:
		secondsCounter = 0;
		LED_off(PORT_A, CAR_YELLOW_LED);// stop CAR_YELLOW_LED so that both yellow leds start blinking together.
		while (secondsCounter < DELAY_5_SECONDS)
 27a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 27e:	85 30       	cpi	r24, 0x05	; 5
 280:	48 f3       	brcs	.-46     	; 0x254 <APP_startPedestrianMode+0x4c>
			LED_toggle(PORT_A, CAR_YELLOW_LED);
			LED_toggle(PORT_B, PEDESTRIANS_YELLOW_LED);
			TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_1_SECOND);
			secondsCounter++;
		}
		LED_off(PORT_A, CAR_YELLOW_LED);
 282:	61 e0       	ldi	r22, 0x01	; 1
 284:	81 e4       	ldi	r24, 0x41	; 65
 286:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		LED_off(PORT_B, PEDESTRIANS_YELLOW_LED);
 28a:	61 e0       	ldi	r22, 0x01	; 1
 28c:	82 e4       	ldi	r24, 0x42	; 66
 28e:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		secondsCounter = 0;
 292:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
		break;// Break from switch and continue the sequence of the rest of the function. 
 296:	1b c0       	rjmp	.+54     	; 0x2ce <APP_startPedestrianMode+0xc6>
		
		
		/* Enable car red light and pedestrian green light.*/
		case CAR_RED_LED:
		LED_on(PORT_A, CAR_RED_LED);
 298:	62 e0       	ldi	r22, 0x02	; 2
 29a:	81 e4       	ldi	r24, 0x41	; 65
 29c:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		LED_on(PORT_B, PEDESTRIANS_GREEN_LED);
 2a0:	60 e0       	ldi	r22, 0x00	; 0
 2a2:	82 e4       	ldi	r24, 0x42	; 66
 2a4:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
		TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_5_SECONDS);
 2a8:	65 e0       	ldi	r22, 0x05	; 5
 2aa:	70 e0       	ldi	r23, 0x00	; 0
 2ac:	80 e0       	ldi	r24, 0x00	; 0
 2ae:	94 e0       	ldi	r25, 0x04	; 4
 2b0:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
		LED_off(PORT_B, PEDESTRIANS_GREEN_LED);
 2b4:	60 e0       	ldi	r22, 0x00	; 0
 2b6:	82 e4       	ldi	r24, 0x42	; 66
 2b8:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
		appMode_g = CAR_MODE;
 2bc:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <appMode_g>
		secondsCounter = 0;
 2c0:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
		timer0InterruptFlag_g = FALSE;
 2c4:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <timer0InterruptFlag_g>
		/* Clearing the interrupt flag to receive new interrupts before leaving the pedestrian function. */
		interruptFlag_g = FALSE;
 2c8:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <interruptFlag_g>
		return;// return from the function without continuing the rest of the sequence.
 2cc:	08 95       	ret
	}
	/* Car red led on, pedestrian green led on.*/
	LED_on(PORT_A, CAR_RED_LED);
 2ce:	62 e0       	ldi	r22, 0x02	; 2
 2d0:	81 e4       	ldi	r24, 0x41	; 65
 2d2:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
	LED_on(PORT_B, PEDESTRIANS_GREEN_LED);
 2d6:	60 e0       	ldi	r22, 0x00	; 0
 2d8:	82 e4       	ldi	r24, 0x42	; 66
 2da:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
	TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_5_SECONDS);
 2de:	65 e0       	ldi	r22, 0x05	; 5
 2e0:	70 e0       	ldi	r23, 0x00	; 0
 2e2:	80 e0       	ldi	r24, 0x00	; 0
 2e4:	94 e0       	ldi	r25, 0x04	; 4
 2e6:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
	LED_off(PORT_A, CAR_RED_LED);
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	81 e4       	ldi	r24, 0x41	; 65
 2ee:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
	
	/* Blink car and pedestrian yellow light while pedestrian green led is still on.*/
	while (secondsCounter < DELAY_5_SECONDS)
 2f2:	13 c0       	rjmp	.+38     	; 0x31a <APP_startPedestrianMode+0x112>
	{
		LED_toggle(PORT_A, CAR_YELLOW_LED);
 2f4:	61 e0       	ldi	r22, 0x01	; 1
 2f6:	81 e4       	ldi	r24, 0x41	; 65
 2f8:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
		LED_toggle(PORT_B, PEDESTRIANS_YELLOW_LED);
 2fc:	61 e0       	ldi	r22, 0x01	; 1
 2fe:	82 e4       	ldi	r24, 0x42	; 66
 300:	0e 94 df 01 	call	0x3be	; 0x3be <LED_toggle>
		TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_1_SECOND);
 304:	61 e0       	ldi	r22, 0x01	; 1
 306:	70 e0       	ldi	r23, 0x00	; 0
 308:	80 e0       	ldi	r24, 0x00	; 0
 30a:	94 e0       	ldi	r25, 0x04	; 4
 30c:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
		secondsCounter++;
 310:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 314:	8f 5f       	subi	r24, 0xFF	; 255
 316:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	LED_on(PORT_B, PEDESTRIANS_GREEN_LED);
	TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_5_SECONDS);
	LED_off(PORT_A, CAR_RED_LED);
	
	/* Blink car and pedestrian yellow light while pedestrian green led is still on.*/
	while (secondsCounter < DELAY_5_SECONDS)
 31a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 31e:	85 30       	cpi	r24, 0x05	; 5
 320:	48 f3       	brcs	.-46     	; 0x2f4 <APP_startPedestrianMode+0xec>
		LED_toggle(PORT_A, CAR_YELLOW_LED);
		LED_toggle(PORT_B, PEDESTRIANS_YELLOW_LED);
		TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_1_SECOND);
		secondsCounter++;
	}
	LED_off(PORT_A, CAR_YELLOW_LED);
 322:	61 e0       	ldi	r22, 0x01	; 1
 324:	81 e4       	ldi	r24, 0x41	; 65
 326:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
	LED_off(PORT_B, PEDESTRIANS_YELLOW_LED);
 32a:	61 e0       	ldi	r22, 0x01	; 1
 32c:	82 e4       	ldi	r24, 0x42	; 66
 32e:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
	LED_off(PORT_B, PEDESTRIANS_GREEN_LED);
 332:	60 e0       	ldi	r22, 0x00	; 0
 334:	82 e4       	ldi	r24, 0x42	; 66
 336:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
	
	/* car green led on, pedestrian red led on.*/
	LED_on(PORT_A, CAR_GREEN_LED);
 33a:	60 e0       	ldi	r22, 0x00	; 0
 33c:	81 e4       	ldi	r24, 0x41	; 65
 33e:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
	LED_on(PORT_B, PEDESTRIANS_RED_LED);
 342:	62 e0       	ldi	r22, 0x02	; 2
 344:	82 e4       	ldi	r24, 0x42	; 66
 346:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <LED_on>
	TIMER2_delay(TIMER2_PRESCALER_1024, DELAY_5_SECONDS);
 34a:	65 e0       	ldi	r22, 0x05	; 5
 34c:	70 e0       	ldi	r23, 0x00	; 0
 34e:	80 e0       	ldi	r24, 0x00	; 0
 350:	94 e0       	ldi	r25, 0x04	; 4
 352:	0e 94 af 03 	call	0x75e	; 0x75e <TIMER2_delay>
	LED_off(PORT_B, PEDESTRIANS_RED_LED);
 356:	62 e0       	ldi	r22, 0x02	; 2
 358:	82 e4       	ldi	r24, 0x42	; 66
 35a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <LED_off>
	
	/* set previousCarLed & currentCarLed values before returning. */
	previousCarLed = CAR_GREEN_LED;
 35e:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <previousCarLed>
	currentCarLed = CAR_YELLOW_LED;
 362:	81 e0       	ldi	r24, 0x01	; 1
 364:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <currentCarLed>
	
	appMode_g = CAR_MODE;// change app mode to CAR_MODE
 368:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <appMode_g>
	secondsCounter = 0;
 36c:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
	timer0InterruptFlag_g = TRUE;
 370:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <timer0InterruptFlag_g>
/* Clearing the interrupt flag to receive new interrupts before leaving the pedestrian function. */
	interruptFlag_g = FALSE;
 374:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <interruptFlag_g>
 378:	08 95       	ret

0000037a <APP_switchMode>:
}
/* This function is the callback function which will be called by INT0 upon triggering the ISR */
void APP_switchMode()
{
	GICR &= ~(1<<BIT6);// disabling INTO to avoid double press and long press.
 37a:	8b b7       	in	r24, 0x3b	; 59
 37c:	8f 7b       	andi	r24, 0xBF	; 191
 37e:	8b bf       	out	0x3b, r24	; 59
	
	/* Switch from car mode to pedestrians mode */
	if (appMode_g == CAR_MODE)
 380:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <appMode_g>
 384:	81 11       	cpse	r24, r1
 386:	05 c0       	rjmp	.+10     	; 0x392 <APP_switchMode+0x18>
	{
		appMode_g = PEDESTRIAN_MODE;
 388:	81 e0       	ldi	r24, 0x01	; 1
 38a:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <appMode_g>
		APP_startPedestrianMode();
 38e:	0e 94 04 01 	call	0x208	; 0x208 <APP_startPedestrianMode>
	}
	GICR |= (1<<BIT6);// re-enabling INT0
 392:	8b b7       	in	r24, 0x3b	; 59
 394:	80 64       	ori	r24, 0x40	; 64
 396:	8b bf       	out	0x3b, r24	; 59
 398:	08 95       	ret

0000039a <LED_init>:
//	  LED Port and LED Pin.
// 2. The function will set the direction of the pin connected to the LED as output.
// 3. The function will return an error state to indicate whether everything is OK.
EN_ledError_t LED_init (uint8_t ledPort, uint8_t ledPin)
{
	uint8_t errorState = DIO_init(ledPort, ledPin, OUT);
 39a:	41 e0       	ldi	r20, 0x01	; 1
 39c:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <DIO_init>
	
	switch (errorState)
 3a0:	81 11       	cpse	r24, r1
		case DIO_OK:
		return LED_OK;
		break;
		
		default:
		return WRONG_LED_INIT;
 3a2:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
}
 3a4:	08 95       	ret

000003a6 <LED_on>:
//	  LED Port and LED Pin.
// 2. The function will set the value of the pin connected to the LED as HIGH.
// 3. The function will return an error state to indicate whether everything is OK.
EN_ledError_t LED_on (uint8_t ledPort, uint8_t ledPin)
{
	uint8_t errorState = DIO_write(ledPort, ledPin, HIGH);
 3a6:	41 e0       	ldi	r20, 0x01	; 1
 3a8:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <DIO_write>
	
	switch (errorState)
 3ac:	81 11       	cpse	r24, r1
		case DIO_OK:
		return LED_OK;
		break;
		
		default:
		return WRONG_LED_ON;
 3ae:	82 e0       	ldi	r24, 0x02	; 2
		break;
	}
}
 3b0:	08 95       	ret

000003b2 <LED_off>:
//	  LED Port and LED Pin.
// 2. The function will set the value of the pin connected to the LED as LOW.
// 3. The function will return an error state to indicate whether everything is OK.
EN_ledError_t LED_off (uint8_t ledPort, uint8_t ledPin)
{
	uint8_t errorState = DIO_write(ledPort, ledPin, LOW);
 3b2:	40 e0       	ldi	r20, 0x00	; 0
 3b4:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <DIO_write>
	
	switch (errorState)
 3b8:	81 11       	cpse	r24, r1
		case DIO_OK:
		return LED_OK;
		break;
		
		default:
		return WRONG_LED_OFF;
 3ba:	83 e0       	ldi	r24, 0x03	; 3
		break;
	}
}
 3bc:	08 95       	ret

000003be <LED_toggle>:
//	  LED Port and LED Pin.
// 2. The function will toggle the value of the pin connected to the LED.
// 3. The function will return an error state to indicate whether everything is OK.
EN_ledError_t LED_toggle (uint8_t ledPort, uint8_t ledPin)
{
	uint8_t errorState = DIO_toggle(ledPort, ledPin);
 3be:	0e 94 0d 03 	call	0x61a	; 0x61a <DIO_toggle>
	
	switch (errorState)
 3c2:	81 11       	cpse	r24, r1
		case DIO_OK:
		return LED_OK;
		break;
		
		default:
		return WRONG_LED_TOGGLE;
 3c4:	84 e0       	ldi	r24, 0x04	; 4
		break;
	}
 3c6:	08 95       	ret

000003c8 <main>:
{
	//APP_testTimer();
		
	//APP_testModule();
    
	APP_init();
 3c8:	0e 94 3e 00 	call	0x7c	; 0x7c <APP_init>
	
    for(;;)
    {
		APP_start();
 3cc:	0e 94 fd 00 	call	0x1fa	; 0x1fa <APP_start>
 3d0:	fd cf       	rjmp	.-6      	; 0x3cc <main+0x4>

000003d2 <DIO_init>:
// 2. Port Number, Pin Number, and Pin Direction.
// 3. Depending on the arguments, the function will initialize that specific pin and define its direction.
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_init(uint8_t portNumber, uint8_t pinNumber, uint8_t direction)
{
	if((pinNumber < 0) || (pinNumber > 7))
 3d2:	68 30       	cpi	r22, 0x08	; 8
 3d4:	08 f0       	brcs	.+2      	; 0x3d8 <DIO_init+0x6>
 3d6:	83 c0       	rjmp	.+262    	; 0x4de <__EEPROM_REGION_LENGTH__+0xde>
	{
		return WRONG_DIO_INIT;
	}
	else
	{
		switch(portNumber)
 3d8:	82 34       	cpi	r24, 0x42	; 66
 3da:	49 f1       	breq	.+82     	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
 3dc:	18 f4       	brcc	.+6      	; 0x3e4 <DIO_init+0x12>
 3de:	81 34       	cpi	r24, 0x41	; 65
 3e0:	41 f0       	breq	.+16     	; 0x3f2 <DIO_init+0x20>
 3e2:	7f c0       	rjmp	.+254    	; 0x4e2 <__EEPROM_REGION_LENGTH__+0xe2>
 3e4:	83 34       	cpi	r24, 0x43	; 67
 3e6:	09 f4       	brne	.+2      	; 0x3ea <DIO_init+0x18>
 3e8:	40 c0       	rjmp	.+128    	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
 3ea:	84 34       	cpi	r24, 0x44	; 68
 3ec:	09 f4       	brne	.+2      	; 0x3f0 <DIO_init+0x1e>
 3ee:	5a c0       	rjmp	.+180    	; 0x4a4 <__EEPROM_REGION_LENGTH__+0xa4>
 3f0:	78 c0       	rjmp	.+240    	; 0x4e2 <__EEPROM_REGION_LENGTH__+0xe2>
		{
			case PORT_A:
				if(direction == IN)
 3f2:	41 11       	cpse	r20, r1
 3f4:	0d c0       	rjmp	.+26     	; 0x410 <__EEPROM_REGION_LENGTH__+0x10>
				{
					CLR_BIT(DDRA,pinNumber);
 3f6:	2a b3       	in	r18, 0x1a	; 26
 3f8:	81 e0       	ldi	r24, 0x01	; 1
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	02 c0       	rjmp	.+4      	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
 3fe:	88 0f       	add	r24, r24
 400:	99 1f       	adc	r25, r25
 402:	6a 95       	dec	r22
 404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_init+0x2c>
 406:	80 95       	com	r24
 408:	82 23       	and	r24, r18
 40a:	8a bb       	out	0x1a, r24	; 26
					return DIO_OK;
 40c:	80 e0       	ldi	r24, 0x00	; 0
 40e:	08 95       	ret
				}
				else if(direction == OUT)
 410:	41 30       	cpi	r20, 0x01	; 1
 412:	09 f0       	breq	.+2      	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
 414:	68 c0       	rjmp	.+208    	; 0x4e6 <__EEPROM_REGION_LENGTH__+0xe6>
				{
					SET_BIT(DDRA,pinNumber);
 416:	2a b3       	in	r18, 0x1a	; 26
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	90 e0       	ldi	r25, 0x00	; 0
 41c:	02 c0       	rjmp	.+4      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
 41e:	88 0f       	add	r24, r24
 420:	99 1f       	adc	r25, r25
 422:	6a 95       	dec	r22
 424:	e2 f7       	brpl	.-8      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 426:	82 2b       	or	r24, r18
 428:	8a bb       	out	0x1a, r24	; 26
					return DIO_OK;
 42a:	80 e0       	ldi	r24, 0x00	; 0
 42c:	08 95       	ret
					return WRONG_DIO_INIT;
				}
			break;
			
			case PORT_B:
				if(direction == IN)
 42e:	41 11       	cpse	r20, r1
 430:	0d c0       	rjmp	.+26     	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
				{
					CLR_BIT(DDRB,pinNumber);
 432:	27 b3       	in	r18, 0x17	; 23
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	02 c0       	rjmp	.+4      	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
 43a:	88 0f       	add	r24, r24
 43c:	99 1f       	adc	r25, r25
 43e:	6a 95       	dec	r22
 440:	e2 f7       	brpl	.-8      	; 0x43a <__EEPROM_REGION_LENGTH__+0x3a>
 442:	80 95       	com	r24
 444:	82 23       	and	r24, r18
 446:	87 bb       	out	0x17, r24	; 23
					return DIO_OK;
 448:	80 e0       	ldi	r24, 0x00	; 0
 44a:	08 95       	ret
				}
				else if(direction == OUT)
 44c:	41 30       	cpi	r20, 0x01	; 1
 44e:	09 f0       	breq	.+2      	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
 450:	4c c0       	rjmp	.+152    	; 0x4ea <__EEPROM_REGION_LENGTH__+0xea>
				{
					SET_BIT(DDRB,pinNumber);
 452:	27 b3       	in	r18, 0x17	; 23
 454:	81 e0       	ldi	r24, 0x01	; 1
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	02 c0       	rjmp	.+4      	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
 45a:	88 0f       	add	r24, r24
 45c:	99 1f       	adc	r25, r25
 45e:	6a 95       	dec	r22
 460:	e2 f7       	brpl	.-8      	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
 462:	82 2b       	or	r24, r18
 464:	87 bb       	out	0x17, r24	; 23
					return DIO_OK;
 466:	80 e0       	ldi	r24, 0x00	; 0
 468:	08 95       	ret
					return WRONG_DIO_INIT;
				}
				break;
				
			case PORT_C:
				if(direction == IN)
 46a:	41 11       	cpse	r20, r1
 46c:	0d c0       	rjmp	.+26     	; 0x488 <__EEPROM_REGION_LENGTH__+0x88>
				{
					CLR_BIT(DDRC,pinNumber);
 46e:	24 b3       	in	r18, 0x14	; 20
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	90 e0       	ldi	r25, 0x00	; 0
 474:	02 c0       	rjmp	.+4      	; 0x47a <__EEPROM_REGION_LENGTH__+0x7a>
 476:	88 0f       	add	r24, r24
 478:	99 1f       	adc	r25, r25
 47a:	6a 95       	dec	r22
 47c:	e2 f7       	brpl	.-8      	; 0x476 <__EEPROM_REGION_LENGTH__+0x76>
 47e:	80 95       	com	r24
 480:	82 23       	and	r24, r18
 482:	84 bb       	out	0x14, r24	; 20
					return DIO_OK;
 484:	80 e0       	ldi	r24, 0x00	; 0
 486:	08 95       	ret
				}
				else if(direction == OUT)
 488:	41 30       	cpi	r20, 0x01	; 1
 48a:	89 f5       	brne	.+98     	; 0x4ee <__EEPROM_REGION_LENGTH__+0xee>
				{
					SET_BIT(DDRC,pinNumber);
 48c:	24 b3       	in	r18, 0x14	; 20
 48e:	81 e0       	ldi	r24, 0x01	; 1
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	02 c0       	rjmp	.+4      	; 0x498 <__EEPROM_REGION_LENGTH__+0x98>
 494:	88 0f       	add	r24, r24
 496:	99 1f       	adc	r25, r25
 498:	6a 95       	dec	r22
 49a:	e2 f7       	brpl	.-8      	; 0x494 <__EEPROM_REGION_LENGTH__+0x94>
 49c:	82 2b       	or	r24, r18
 49e:	84 bb       	out	0x14, r24	; 20
					return DIO_OK;
 4a0:	80 e0       	ldi	r24, 0x00	; 0
 4a2:	08 95       	ret
					return WRONG_DIO_INIT;
				}
				break;
				
			case PORT_D:
				if(direction == IN)
 4a4:	41 11       	cpse	r20, r1
 4a6:	0d c0       	rjmp	.+26     	; 0x4c2 <__EEPROM_REGION_LENGTH__+0xc2>
				{
					CLR_BIT(DDRD,pinNumber);
 4a8:	21 b3       	in	r18, 0x11	; 17
 4aa:	81 e0       	ldi	r24, 0x01	; 1
 4ac:	90 e0       	ldi	r25, 0x00	; 0
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <__EEPROM_REGION_LENGTH__+0xb4>
 4b0:	88 0f       	add	r24, r24
 4b2:	99 1f       	adc	r25, r25
 4b4:	6a 95       	dec	r22
 4b6:	e2 f7       	brpl	.-8      	; 0x4b0 <__EEPROM_REGION_LENGTH__+0xb0>
 4b8:	80 95       	com	r24
 4ba:	82 23       	and	r24, r18
 4bc:	81 bb       	out	0x11, r24	; 17
					return DIO_OK;
 4be:	80 e0       	ldi	r24, 0x00	; 0
 4c0:	08 95       	ret
				}
				else if(direction == OUT)
 4c2:	41 30       	cpi	r20, 0x01	; 1
 4c4:	b1 f4       	brne	.+44     	; 0x4f2 <__EEPROM_REGION_LENGTH__+0xf2>
				{
					SET_BIT(DDRD,pinNumber);
 4c6:	21 b3       	in	r18, 0x11	; 17
 4c8:	81 e0       	ldi	r24, 0x01	; 1
 4ca:	90 e0       	ldi	r25, 0x00	; 0
 4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <__EEPROM_REGION_LENGTH__+0xd2>
 4ce:	88 0f       	add	r24, r24
 4d0:	99 1f       	adc	r25, r25
 4d2:	6a 95       	dec	r22
 4d4:	e2 f7       	brpl	.-8      	; 0x4ce <__EEPROM_REGION_LENGTH__+0xce>
 4d6:	82 2b       	or	r24, r18
 4d8:	81 bb       	out	0x11, r24	; 17
					return DIO_OK;
 4da:	80 e0       	ldi	r24, 0x00	; 0
 4dc:	08 95       	ret
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_init(uint8_t portNumber, uint8_t pinNumber, uint8_t direction)
{
	if((pinNumber < 0) || (pinNumber > 7))
	{
		return WRONG_DIO_INIT;
 4de:	81 e0       	ldi	r24, 0x01	; 1
 4e0:	08 95       	ret
					return WRONG_DIO_INIT;
				}
				break;
				
			default:
				return WRONG_DIO_INIT;
 4e2:	81 e0       	ldi	r24, 0x01	; 1
 4e4:	08 95       	ret
					SET_BIT(DDRA,pinNumber);
					return DIO_OK;
				}
				else
				{
					return WRONG_DIO_INIT;
 4e6:	81 e0       	ldi	r24, 0x01	; 1
 4e8:	08 95       	ret
					SET_BIT(DDRB,pinNumber);
					return DIO_OK;
				}
				else
				{
					return WRONG_DIO_INIT;
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	08 95       	ret
					SET_BIT(DDRC,pinNumber);
					return DIO_OK;
				}
				else
				{
					return WRONG_DIO_INIT;
 4ee:	81 e0       	ldi	r24, 0x01	; 1
 4f0:	08 95       	ret
					SET_BIT(DDRD,pinNumber);
					return DIO_OK;
				}
				else
				{
					return WRONG_DIO_INIT;
 4f2:	81 e0       	ldi	r24, 0x01	; 1
			default:
				return WRONG_DIO_INIT;
				break;
		}
	}
}
 4f4:	08 95       	ret

000004f6 <DIO_write>:
// 2. Port Number, Pin Number, and Pin Value.
// 3. Depending on the arguments, the function will write the pin value on the desired pin.
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_write(uint8_t portNumber, uint8_t pinNumber, uint8_t value)
{
	if((pinNumber < 0) || (pinNumber > 7))
 4f6:	68 30       	cpi	r22, 0x08	; 8
 4f8:	08 f0       	brcs	.+2      	; 0x4fc <DIO_write+0x6>
 4fa:	83 c0       	rjmp	.+262    	; 0x602 <DIO_write+0x10c>
	{
		return WRONG_DIO_WRITE;
	}
	else
	{
		switch(portNumber)
 4fc:	82 34       	cpi	r24, 0x42	; 66
 4fe:	49 f1       	breq	.+82     	; 0x552 <DIO_write+0x5c>
 500:	18 f4       	brcc	.+6      	; 0x508 <DIO_write+0x12>
 502:	81 34       	cpi	r24, 0x41	; 65
 504:	41 f0       	breq	.+16     	; 0x516 <DIO_write+0x20>
 506:	7f c0       	rjmp	.+254    	; 0x606 <DIO_write+0x110>
 508:	83 34       	cpi	r24, 0x43	; 67
 50a:	09 f4       	brne	.+2      	; 0x50e <DIO_write+0x18>
 50c:	40 c0       	rjmp	.+128    	; 0x58e <DIO_write+0x98>
 50e:	84 34       	cpi	r24, 0x44	; 68
 510:	09 f4       	brne	.+2      	; 0x514 <DIO_write+0x1e>
 512:	5a c0       	rjmp	.+180    	; 0x5c8 <DIO_write+0xd2>
 514:	78 c0       	rjmp	.+240    	; 0x606 <DIO_write+0x110>
		{
			case PORT_A:
			if(value == LOW)
 516:	41 11       	cpse	r20, r1
 518:	0d c0       	rjmp	.+26     	; 0x534 <DIO_write+0x3e>
			{
				CLR_BIT(PORTA,pinNumber);	// write 0
 51a:	2b b3       	in	r18, 0x1b	; 27
 51c:	81 e0       	ldi	r24, 0x01	; 1
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	02 c0       	rjmp	.+4      	; 0x526 <DIO_write+0x30>
 522:	88 0f       	add	r24, r24
 524:	99 1f       	adc	r25, r25
 526:	6a 95       	dec	r22
 528:	e2 f7       	brpl	.-8      	; 0x522 <DIO_write+0x2c>
 52a:	80 95       	com	r24
 52c:	82 23       	and	r24, r18
 52e:	8b bb       	out	0x1b, r24	; 27
				return DIO_OK;
 530:	80 e0       	ldi	r24, 0x00	; 0
 532:	08 95       	ret
			}
			else if(value == HIGH)
 534:	41 30       	cpi	r20, 0x01	; 1
 536:	09 f0       	breq	.+2      	; 0x53a <DIO_write+0x44>
 538:	68 c0       	rjmp	.+208    	; 0x60a <DIO_write+0x114>
			{
				SET_BIT(PORTA,pinNumber);	// write 1
 53a:	2b b3       	in	r18, 0x1b	; 27
 53c:	81 e0       	ldi	r24, 0x01	; 1
 53e:	90 e0       	ldi	r25, 0x00	; 0
 540:	02 c0       	rjmp	.+4      	; 0x546 <DIO_write+0x50>
 542:	88 0f       	add	r24, r24
 544:	99 1f       	adc	r25, r25
 546:	6a 95       	dec	r22
 548:	e2 f7       	brpl	.-8      	; 0x542 <DIO_write+0x4c>
 54a:	82 2b       	or	r24, r18
 54c:	8b bb       	out	0x1b, r24	; 27
				return DIO_OK;
 54e:	80 e0       	ldi	r24, 0x00	; 0
 550:	08 95       	ret
				return WRONG_DIO_WRITE;
			}
			break;
			
			case PORT_B:
			if(value == LOW)
 552:	41 11       	cpse	r20, r1
 554:	0d c0       	rjmp	.+26     	; 0x570 <DIO_write+0x7a>
			{
				CLR_BIT(PORTB,pinNumber);	// write 0
 556:	28 b3       	in	r18, 0x18	; 24
 558:	81 e0       	ldi	r24, 0x01	; 1
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	02 c0       	rjmp	.+4      	; 0x562 <DIO_write+0x6c>
 55e:	88 0f       	add	r24, r24
 560:	99 1f       	adc	r25, r25
 562:	6a 95       	dec	r22
 564:	e2 f7       	brpl	.-8      	; 0x55e <DIO_write+0x68>
 566:	80 95       	com	r24
 568:	82 23       	and	r24, r18
 56a:	88 bb       	out	0x18, r24	; 24
				return DIO_OK;
 56c:	80 e0       	ldi	r24, 0x00	; 0
 56e:	08 95       	ret
			}
			else if(value == HIGH)
 570:	41 30       	cpi	r20, 0x01	; 1
 572:	09 f0       	breq	.+2      	; 0x576 <DIO_write+0x80>
 574:	4c c0       	rjmp	.+152    	; 0x60e <DIO_write+0x118>
			{
				SET_BIT(PORTB,pinNumber);	// write 1
 576:	28 b3       	in	r18, 0x18	; 24
 578:	81 e0       	ldi	r24, 0x01	; 1
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	02 c0       	rjmp	.+4      	; 0x582 <DIO_write+0x8c>
 57e:	88 0f       	add	r24, r24
 580:	99 1f       	adc	r25, r25
 582:	6a 95       	dec	r22
 584:	e2 f7       	brpl	.-8      	; 0x57e <DIO_write+0x88>
 586:	82 2b       	or	r24, r18
 588:	88 bb       	out	0x18, r24	; 24
				return DIO_OK;
 58a:	80 e0       	ldi	r24, 0x00	; 0
 58c:	08 95       	ret
				return WRONG_DIO_WRITE;
			}
			break;
			
			case PORT_C:
			if(value == LOW)
 58e:	41 11       	cpse	r20, r1
 590:	0d c0       	rjmp	.+26     	; 0x5ac <DIO_write+0xb6>
			{
				CLR_BIT(PORTC,pinNumber);	// write 0
 592:	25 b3       	in	r18, 0x15	; 21
 594:	81 e0       	ldi	r24, 0x01	; 1
 596:	90 e0       	ldi	r25, 0x00	; 0
 598:	02 c0       	rjmp	.+4      	; 0x59e <DIO_write+0xa8>
 59a:	88 0f       	add	r24, r24
 59c:	99 1f       	adc	r25, r25
 59e:	6a 95       	dec	r22
 5a0:	e2 f7       	brpl	.-8      	; 0x59a <DIO_write+0xa4>
 5a2:	80 95       	com	r24
 5a4:	82 23       	and	r24, r18
 5a6:	85 bb       	out	0x15, r24	; 21
				return DIO_OK;
 5a8:	80 e0       	ldi	r24, 0x00	; 0
 5aa:	08 95       	ret
			}
			else if(value == HIGH)
 5ac:	41 30       	cpi	r20, 0x01	; 1
 5ae:	89 f5       	brne	.+98     	; 0x612 <DIO_write+0x11c>
			{
				SET_BIT(PORTC,pinNumber);	// write 1
 5b0:	25 b3       	in	r18, 0x15	; 21
 5b2:	81 e0       	ldi	r24, 0x01	; 1
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	02 c0       	rjmp	.+4      	; 0x5bc <DIO_write+0xc6>
 5b8:	88 0f       	add	r24, r24
 5ba:	99 1f       	adc	r25, r25
 5bc:	6a 95       	dec	r22
 5be:	e2 f7       	brpl	.-8      	; 0x5b8 <DIO_write+0xc2>
 5c0:	82 2b       	or	r24, r18
 5c2:	85 bb       	out	0x15, r24	; 21
				return DIO_OK;
 5c4:	80 e0       	ldi	r24, 0x00	; 0
 5c6:	08 95       	ret
				return WRONG_DIO_WRITE;
			}
			break;
			
			case PORT_D:
			if(value == LOW)
 5c8:	41 11       	cpse	r20, r1
 5ca:	0d c0       	rjmp	.+26     	; 0x5e6 <DIO_write+0xf0>
			{
				CLR_BIT(PORTD,pinNumber);	// write 0
 5cc:	22 b3       	in	r18, 0x12	; 18
 5ce:	81 e0       	ldi	r24, 0x01	; 1
 5d0:	90 e0       	ldi	r25, 0x00	; 0
 5d2:	02 c0       	rjmp	.+4      	; 0x5d8 <DIO_write+0xe2>
 5d4:	88 0f       	add	r24, r24
 5d6:	99 1f       	adc	r25, r25
 5d8:	6a 95       	dec	r22
 5da:	e2 f7       	brpl	.-8      	; 0x5d4 <DIO_write+0xde>
 5dc:	80 95       	com	r24
 5de:	82 23       	and	r24, r18
 5e0:	82 bb       	out	0x12, r24	; 18
				return DIO_OK;
 5e2:	80 e0       	ldi	r24, 0x00	; 0
 5e4:	08 95       	ret
			}
			else if(value == HIGH)
 5e6:	41 30       	cpi	r20, 0x01	; 1
 5e8:	b1 f4       	brne	.+44     	; 0x616 <DIO_write+0x120>
			{
				SET_BIT(PORTD,pinNumber);	// write 1
 5ea:	22 b3       	in	r18, 0x12	; 18
 5ec:	81 e0       	ldi	r24, 0x01	; 1
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <DIO_write+0x100>
 5f2:	88 0f       	add	r24, r24
 5f4:	99 1f       	adc	r25, r25
 5f6:	6a 95       	dec	r22
 5f8:	e2 f7       	brpl	.-8      	; 0x5f2 <DIO_write+0xfc>
 5fa:	82 2b       	or	r24, r18
 5fc:	82 bb       	out	0x12, r24	; 18
				return DIO_OK;
 5fe:	80 e0       	ldi	r24, 0x00	; 0
 600:	08 95       	ret
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_write(uint8_t portNumber, uint8_t pinNumber, uint8_t value)
{
	if((pinNumber < 0) || (pinNumber > 7))
	{
		return WRONG_DIO_WRITE;
 602:	82 e0       	ldi	r24, 0x02	; 2
 604:	08 95       	ret
				return WRONG_DIO_WRITE;
			}
			break;
			
			default:
			return WRONG_DIO_WRITE;
 606:	82 e0       	ldi	r24, 0x02	; 2
 608:	08 95       	ret
				SET_BIT(PORTA,pinNumber);	// write 1
				return DIO_OK;
			}
			else
			{
				return WRONG_DIO_WRITE;
 60a:	82 e0       	ldi	r24, 0x02	; 2
 60c:	08 95       	ret
				SET_BIT(PORTB,pinNumber);	// write 1
				return DIO_OK;
			}
			else
			{
				return WRONG_DIO_WRITE;
 60e:	82 e0       	ldi	r24, 0x02	; 2
 610:	08 95       	ret
				SET_BIT(PORTC,pinNumber);	// write 1
				return DIO_OK;
			}
			else
			{
				return WRONG_DIO_WRITE;
 612:	82 e0       	ldi	r24, 0x02	; 2
 614:	08 95       	ret
				SET_BIT(PORTD,pinNumber);	// write 1
				return DIO_OK;
			}
			else
			{
				return WRONG_DIO_WRITE;
 616:	82 e0       	ldi	r24, 0x02	; 2
			return WRONG_DIO_WRITE;
			break;
		}
	}
	
}
 618:	08 95       	ret

0000061a <DIO_toggle>:
// 2. Port Number and Pin Number.
// 3. Depending on the arguments, the function will toggle the desired pin.
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_toggle(uint8_t portNumber, uint8_t pinNumber)
{
	if((pinNumber < 0) || (pinNumber > 7))
 61a:	68 30       	cpi	r22, 0x08	; 8
 61c:	d8 f5       	brcc	.+118    	; 0x694 <DIO_toggle+0x7a>
	{
		return WRONG_DIO_TOGGLE;
	}
	else
	{
		switch(portNumber)
 61e:	82 34       	cpi	r24, 0x42	; 66
 620:	a9 f0       	breq	.+42     	; 0x64c <DIO_toggle+0x32>
 622:	18 f4       	brcc	.+6      	; 0x62a <DIO_toggle+0x10>
 624:	81 34       	cpi	r24, 0x41	; 65
 626:	31 f0       	breq	.+12     	; 0x634 <DIO_toggle+0x1a>
 628:	37 c0       	rjmp	.+110    	; 0x698 <DIO_toggle+0x7e>
 62a:	83 34       	cpi	r24, 0x43	; 67
 62c:	d9 f0       	breq	.+54     	; 0x664 <DIO_toggle+0x4a>
 62e:	84 34       	cpi	r24, 0x44	; 68
 630:	29 f1       	breq	.+74     	; 0x67c <DIO_toggle+0x62>
 632:	32 c0       	rjmp	.+100    	; 0x698 <DIO_toggle+0x7e>
		{
			case PORT_A:
			TOG_BIT(PORTA,pinNumber);
 634:	2b b3       	in	r18, 0x1b	; 27
 636:	81 e0       	ldi	r24, 0x01	; 1
 638:	90 e0       	ldi	r25, 0x00	; 0
 63a:	02 c0       	rjmp	.+4      	; 0x640 <DIO_toggle+0x26>
 63c:	88 0f       	add	r24, r24
 63e:	99 1f       	adc	r25, r25
 640:	6a 95       	dec	r22
 642:	e2 f7       	brpl	.-8      	; 0x63c <DIO_toggle+0x22>
 644:	82 27       	eor	r24, r18
 646:	8b bb       	out	0x1b, r24	; 27
			return DIO_OK;
 648:	80 e0       	ldi	r24, 0x00	; 0
 64a:	08 95       	ret
			break;
			
			case PORT_B:
			TOG_BIT(PORTB,pinNumber);
 64c:	28 b3       	in	r18, 0x18	; 24
 64e:	81 e0       	ldi	r24, 0x01	; 1
 650:	90 e0       	ldi	r25, 0x00	; 0
 652:	02 c0       	rjmp	.+4      	; 0x658 <DIO_toggle+0x3e>
 654:	88 0f       	add	r24, r24
 656:	99 1f       	adc	r25, r25
 658:	6a 95       	dec	r22
 65a:	e2 f7       	brpl	.-8      	; 0x654 <DIO_toggle+0x3a>
 65c:	82 27       	eor	r24, r18
 65e:	88 bb       	out	0x18, r24	; 24
			return DIO_OK;
 660:	80 e0       	ldi	r24, 0x00	; 0
 662:	08 95       	ret
			break;
			
			case PORT_C:
			TOG_BIT(PORTC,pinNumber);
 664:	25 b3       	in	r18, 0x15	; 21
 666:	81 e0       	ldi	r24, 0x01	; 1
 668:	90 e0       	ldi	r25, 0x00	; 0
 66a:	02 c0       	rjmp	.+4      	; 0x670 <DIO_toggle+0x56>
 66c:	88 0f       	add	r24, r24
 66e:	99 1f       	adc	r25, r25
 670:	6a 95       	dec	r22
 672:	e2 f7       	brpl	.-8      	; 0x66c <DIO_toggle+0x52>
 674:	82 27       	eor	r24, r18
 676:	85 bb       	out	0x15, r24	; 21
			return DIO_OK;
 678:	80 e0       	ldi	r24, 0x00	; 0
 67a:	08 95       	ret
			break;
			
			case PORT_D:
			TOG_BIT(PORTD,pinNumber);
 67c:	22 b3       	in	r18, 0x12	; 18
 67e:	81 e0       	ldi	r24, 0x01	; 1
 680:	90 e0       	ldi	r25, 0x00	; 0
 682:	02 c0       	rjmp	.+4      	; 0x688 <DIO_toggle+0x6e>
 684:	88 0f       	add	r24, r24
 686:	99 1f       	adc	r25, r25
 688:	6a 95       	dec	r22
 68a:	e2 f7       	brpl	.-8      	; 0x684 <DIO_toggle+0x6a>
 68c:	82 27       	eor	r24, r18
 68e:	82 bb       	out	0x12, r24	; 18
			return DIO_OK;
 690:	80 e0       	ldi	r24, 0x00	; 0
 692:	08 95       	ret
// 4. The function will return an error state to indicate whether everything is OK.
EN_dioError_t DIO_toggle(uint8_t portNumber, uint8_t pinNumber)
{
	if((pinNumber < 0) || (pinNumber > 7))
	{
		return WRONG_DIO_TOGGLE;
 694:	83 e0       	ldi	r24, 0x03	; 3
 696:	08 95       	ret
			TOG_BIT(PORTD,pinNumber);
			return DIO_OK;
			break;
			
			default:
			return WRONG_DIO_TOGGLE;
 698:	83 e0       	ldi	r24, 0x03	; 3
			break;
		}
	}
}
 69a:	08 95       	ret

0000069c <INT_init>:
// 4. Enable INT0.
// 5. Return error state.
EN_intError_t INT_init(uint8_t interruptNumber)
{
	/* Here I am only writing code suitable for INT0. Any other value will return an error. */
	switch (interruptNumber)
 69c:	81 11       	cpse	r24, r1
 69e:	09 c0       	rjmp	.+18     	; 0x6b2 <INT_init+0x16>
	{
		case 0:
		/* Enable global interrupts */
		sei();
 6a0:	78 94       	sei
		/* Interrupt triggers on rising edge */
		MCUCR |= (1<<BIT0) | (1<<BIT1);
 6a2:	85 b7       	in	r24, 0x35	; 53
 6a4:	83 60       	ori	r24, 0x03	; 3
 6a6:	85 bf       	out	0x35, r24	; 53
		/* Enable INT0 */
		GICR |= (1<<BIT6);
 6a8:	8b b7       	in	r24, 0x3b	; 59
 6aa:	80 64       	ori	r24, 0x40	; 64
 6ac:	8b bf       	out	0x3b, r24	; 59
		return INT_OK;
 6ae:	80 e0       	ldi	r24, 0x00	; 0
 6b0:	08 95       	ret
		break;

		default:
		return WRONG_INT_INIT;
 6b2:	81 e0       	ldi	r24, 0x01	; 1
		break;
	}
}
 6b4:	08 95       	ret

000006b6 <setINT0Callback>:
/* This function takes a function as an input and stores its address in INT0Callback pointer to function */
void setINT0Callback (void (*Callback)(void))
{
	INT0Callback = Callback;
 6b6:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <INT0Callback+0x1>
 6ba:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <INT0Callback>
 6be:	08 95       	ret

000006c0 <__vector_1>:
}

/* Interrupt Service Routine for INT0 */
ISR(EXT_INT_0)
{
 6c0:	1f 92       	push	r1
 6c2:	0f 92       	push	r0
 6c4:	0f b6       	in	r0, 0x3f	; 63
 6c6:	0f 92       	push	r0
 6c8:	11 24       	eor	r1, r1
 6ca:	2f 93       	push	r18
 6cc:	3f 93       	push	r19
 6ce:	4f 93       	push	r20
 6d0:	5f 93       	push	r21
 6d2:	6f 93       	push	r22
 6d4:	7f 93       	push	r23
 6d6:	8f 93       	push	r24
 6d8:	9f 93       	push	r25
 6da:	af 93       	push	r26
 6dc:	bf 93       	push	r27
 6de:	ef 93       	push	r30
 6e0:	ff 93       	push	r31
	/* Checking if INT0 got triggered once. */
	if(interruptFlag_g == FALSE)
 6e2:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <interruptFlag_g>
 6e6:	81 11       	cpse	r24, r1
 6e8:	08 c0       	rjmp	.+16     	; 0x6fa <__vector_1+0x3a>
	{
		interruptFlag_g = TRUE; // After Triggering INT0, raising a flag so that it will not trigger again.
 6ea:	81 e0       	ldi	r24, 0x01	; 1
 6ec:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <interruptFlag_g>
		INT0Callback();
 6f0:	e0 91 65 00 	lds	r30, 0x0065	; 0x800065 <INT0Callback>
 6f4:	f0 91 66 00 	lds	r31, 0x0066	; 0x800066 <INT0Callback+0x1>
 6f8:	09 95       	icall
		//interruptFlag_g = FALSE;
	}
 6fa:	ff 91       	pop	r31
 6fc:	ef 91       	pop	r30
 6fe:	bf 91       	pop	r27
 700:	af 91       	pop	r26
 702:	9f 91       	pop	r25
 704:	8f 91       	pop	r24
 706:	7f 91       	pop	r23
 708:	6f 91       	pop	r22
 70a:	5f 91       	pop	r21
 70c:	4f 91       	pop	r20
 70e:	3f 91       	pop	r19
 710:	2f 91       	pop	r18
 712:	0f 90       	pop	r0
 714:	0f be       	out	0x3f, r0	; 63
 716:	0f 90       	pop	r0
 718:	1f 90       	pop	r1
 71a:	18 95       	reti

0000071c <TIMER0_delay>:
 EN_timer0Error_t TIMER0_delay(uint16_t timer0Prescaler, uint16_t delayInSeconds)
 {
	 uint8_t overflowCounter = 0;
	 
	 /* Normal mode */
	 TCCR0 = 0x00;
 71c:	13 be       	out	0x33, r1	; 51
	 /* Start Counting from 12 */
	 TCNT0 = 12;
 71e:	2c e0       	ldi	r18, 0x0C	; 12
 720:	22 bf       	out	0x32, r18	; 50
	 
	 /* Note: Here, I am only writing suitable code for Prescaler 1024. Any other value will return Error */
	 switch(timer0Prescaler)
 722:	81 15       	cp	r24, r1
 724:	94 40       	sbci	r25, 0x04	; 4
 726:	c9 f4       	brne	.+50     	; 0x75a <TIMER0_delay+0x3e>
	 {
		 case TIMER0_PRESCALER_1024:
		 /* Start Timer0 with Prescaler = 1024 */
		 TCCR0 |= (1<<BIT0) | (1<<BIT2);
 728:	83 b7       	in	r24, 0x33	; 51
 72a:	85 60       	ori	r24, 0x05	; 5
 72c:	83 bf       	out	0x33, r24	; 51
// 4. Setting the prescaler value to 1024 in TCCR0.
// 5. Waiting for overflows, then resetting overflow counter and stopping the timer.
// 6. The function will return an error state to indicate whether a correct prescaler is used.
 EN_timer0Error_t TIMER0_delay(uint16_t timer0Prescaler, uint16_t delayInSeconds)
 {
	 uint8_t overflowCounter = 0;
 72e:	20 e0       	ldi	r18, 0x00	; 0
	 {
		 case TIMER0_PRESCALER_1024:
		 /* Start Timer0 with Prescaler = 1024 */
		 TCCR0 |= (1<<BIT0) | (1<<BIT2);
		 /* According to the calculations, the number of overflows required to reach the delay is: delayInSeconds x 4 */
		 while(overflowCounter < (delayInSeconds * 4))
 730:	07 c0       	rjmp	.+14     	; 0x740 <TIMER0_delay+0x24>
		 {
			 while((TIFR & (1<<BIT0)) == 0);
 732:	08 b6       	in	r0, 0x38	; 56
 734:	00 fe       	sbrs	r0, 0
 736:	fd cf       	rjmp	.-6      	; 0x732 <TIMER0_delay+0x16>
			 
			 // Clear overflow flag
			 TIFR|= (1<<BIT0);
 738:	88 b7       	in	r24, 0x38	; 56
 73a:	81 60       	ori	r24, 0x01	; 1
 73c:	88 bf       	out	0x38, r24	; 56
			 
			 overflowCounter++;
 73e:	2f 5f       	subi	r18, 0xFF	; 255
	 {
		 case TIMER0_PRESCALER_1024:
		 /* Start Timer0 with Prescaler = 1024 */
		 TCCR0 |= (1<<BIT0) | (1<<BIT2);
		 /* According to the calculations, the number of overflows required to reach the delay is: delayInSeconds x 4 */
		 while(overflowCounter < (delayInSeconds * 4))
 740:	82 2f       	mov	r24, r18
 742:	90 e0       	ldi	r25, 0x00	; 0
 744:	ab 01       	movw	r20, r22
 746:	44 0f       	add	r20, r20
 748:	55 1f       	adc	r21, r21
 74a:	44 0f       	add	r20, r20
 74c:	55 1f       	adc	r21, r21
 74e:	84 17       	cp	r24, r20
 750:	95 07       	cpc	r25, r21
 752:	78 f3       	brcs	.-34     	; 0x732 <TIMER0_delay+0x16>
			 
			 overflowCounter++;
		 }
		 overflowCounter = 0;
		 /* TIMER0 stop */
		 TCCR0 = 0x00;
 754:	13 be       	out	0x33, r1	; 51
		 return TIMER0_OK;
 756:	80 e0       	ldi	r24, 0x00	; 0
 758:	08 95       	ret
		 break;
		 
		 default:
		 return WRONG_TIMER0_DELAY;
 75a:	83 e0       	ldi	r24, 0x03	; 3
	 }
 }
 75c:	08 95       	ret

0000075e <TIMER2_delay>:
 EN_timer2Error_t TIMER2_delay(uint16_t timer2Prescaler, uint16_t delayInSeconds)
 {
	 uint8_t overflowCounter = 0;
	 
	 /* Normal mode */
	 TCCR2 = 0x00;
 75e:	15 bc       	out	0x25, r1	; 37
	 /* Start Counting from 12 */
	 TCNT2 = 12;
 760:	2c e0       	ldi	r18, 0x0C	; 12
 762:	24 bd       	out	0x24, r18	; 36
	 
	 /* Note: Here, I am only writing suitable code for Prescaler 1024. Any other value will return Error */
	 switch(timer2Prescaler)
 764:	81 15       	cp	r24, r1
 766:	94 40       	sbci	r25, 0x04	; 4
 768:	c9 f4       	brne	.+50     	; 0x79c <TIMER2_delay+0x3e>
	 {
		 case TIMER2_PRESCALER_1024:
		 /* Start Timer2 with Prescaler = 1024 */
		 TCCR2 |= (1<<BIT0) | (1<<BIT1) | (1<<BIT2);
 76a:	85 b5       	in	r24, 0x25	; 37
 76c:	87 60       	ori	r24, 0x07	; 7
 76e:	85 bd       	out	0x25, r24	; 37
// 4. Setting the prescaler value to 1024 in TCCR0.
// 5. Waiting for overflows, then resetting overflow counter and stopping the timer.
// 6. The function will return an error state to indicate whether a correct prescaler is used.
 EN_timer2Error_t TIMER2_delay(uint16_t timer2Prescaler, uint16_t delayInSeconds)
 {
	 uint8_t overflowCounter = 0;
 770:	20 e0       	ldi	r18, 0x00	; 0
	 {
		 case TIMER2_PRESCALER_1024:
		 /* Start Timer2 with Prescaler = 1024 */
		 TCCR2 |= (1<<BIT0) | (1<<BIT1) | (1<<BIT2);
		 /* According to the calculations, the number of overflows required to reach the delay is: delayInSeconds x 4 */
		 while(overflowCounter < (delayInSeconds * 4))
 772:	07 c0       	rjmp	.+14     	; 0x782 <TIMER2_delay+0x24>
		 {
			 while((TIFR & (1<<BIT6)) == 0);
 774:	08 b6       	in	r0, 0x38	; 56
 776:	06 fe       	sbrs	r0, 6
 778:	fd cf       	rjmp	.-6      	; 0x774 <TIMER2_delay+0x16>
			 
			 // Clear overflow flag
			 TIFR|= (1<<BIT6);
 77a:	88 b7       	in	r24, 0x38	; 56
 77c:	80 64       	ori	r24, 0x40	; 64
 77e:	88 bf       	out	0x38, r24	; 56
			 
			 overflowCounter++;
 780:	2f 5f       	subi	r18, 0xFF	; 255
	 {
		 case TIMER2_PRESCALER_1024:
		 /* Start Timer2 with Prescaler = 1024 */
		 TCCR2 |= (1<<BIT0) | (1<<BIT1) | (1<<BIT2);
		 /* According to the calculations, the number of overflows required to reach the delay is: delayInSeconds x 4 */
		 while(overflowCounter < (delayInSeconds * 4))
 782:	82 2f       	mov	r24, r18
 784:	90 e0       	ldi	r25, 0x00	; 0
 786:	ab 01       	movw	r20, r22
 788:	44 0f       	add	r20, r20
 78a:	55 1f       	adc	r21, r21
 78c:	44 0f       	add	r20, r20
 78e:	55 1f       	adc	r21, r21
 790:	84 17       	cp	r24, r20
 792:	95 07       	cpc	r25, r21
 794:	78 f3       	brcs	.-34     	; 0x774 <TIMER2_delay+0x16>
			 
			 overflowCounter++;
		 }
		 overflowCounter = 0;
		 /* Timer2 stop */
		 TCCR2 = 0x00;
 796:	15 bc       	out	0x25, r1	; 37
		 return TIMER2_OK;
 798:	80 e0       	ldi	r24, 0x00	; 0
 79a:	08 95       	ret
		 break;
		 
		 default:
		 return WRONG_TIMER2_DELAY;
 79c:	83 e0       	ldi	r24, 0x03	; 3
	 }
 }
 79e:	08 95       	ret

000007a0 <_exit>:
 7a0:	f8 94       	cli

000007a2 <__stop_program>:
 7a2:	ff cf       	rjmp	.-2      	; 0x7a2 <__stop_program>
